/*Выяснить максимально возможное число потоков OpenMP на данном компьютере (функция omp_get_max_threads()). Сравнить с числом физических и логических ядер в диспетчере задач. 
 
Текст программы: */
#include <iostream> 
#include <omp.h> 
 
int main() 
{ 
   printf("%d\n", omp_get_max_threads()); 
 
   system("pause"); 
} 
 /*
Результат: 

В диспетчере задач отображено два физических ядра и четыре логических. 
 
 
Написать программу “Hello world”. Поместить ее в параллельную секцию (#pragma omp parallel). Запустить программу и объяснить результат. 
Текст программы: */

#include <iostream> 
#include <stdio.h> 
#include <omp.h> 
 
int main() 
{ 
#pragma omp parallel 
printf("Hello, World!\n"); 
 
system("pause"); 
} 
 /*
Результат:  
Hello, World! 
Hello, World! 
Hello, World! 
Hello, World! 
Текст был напечатан четыре раза по причине того, что четыре процессора прошли секцию с оператором print. 
 
 
Вывести общее число потоков, выполняющихся внутри параллельной секции (функция omp_get_num_threads()). 
Сделать так, чтобы каждый поток выводил “Hello world” и свой номер. 
Текст программы: */ 

#include <iostream> 
#include <stdio.h> 
#include <omp.h> 
 
int main() 
{ 
setlocale(LC_ALL, "Russian"); 
#pragma omp parallel 
 
printf("Поток %d: Hello, World!\n", omp_get_thread_num()); 
 
system("pause"); 
} 
 
 /*
Результат:  
Поток 0: Hello, World! 
Поток 3: Hello, World! 
Поток 1: Hello, World! 
Поток 2: Hello, World! 
 
Программа выводит текст с номером потока. Потоки работают одновременно и по этому написаны не по порядку.  
 
Выполнить предыдущее задание, используя параллельные секции (#pragma omp parallel sections). Задать количество секций больше, чем число потоков. Объяснить результат. 
Текст программы: */

#include <iostream> 
#include <stdio.h> 
#include <omp.h> 
 
int main() 
{ 
setlocale(LC_ALL, "Russian"); 
#pragma omp parallel sections 
{ 
#pragma omp section 
printf("Поток %d: Hello, World!\n", omp_get_thread_num()); 
#pragma omp section 
printf("Поток %d: Hello, World!\n", omp_get_thread_num()); 
#pragma omp section 
printf("Поток %d: Hello, World!\n", omp_get_thread_num()); 
#pragma omp section 
printf("Поток %d: Hello, World!\n", omp_get_thread_num()); 
#pragma omp section 
printf("Поток %d: Hello, World!\n", omp_get_thread_num()); 
#pragma omp section 
printf("Поток %d: Hello, World!\n", omp_get_thread_num()); 
#pragma omp section 
printf("Поток %d: Hello, World!\n", omp_get_thread_num()); 
#pragma omp section 
printf("Поток %d: Hello, World!\n", omp_get_thread_num()); 
} 
system("pause"); 
} 
 /*
Результат: 
Поток 0: Hello, World! 
Поток 0: Hello, World! 
Поток 0: Hello, World! 
Поток 2: Hello, World! 
Поток 1: Hello, World! 
Поток 3: Hello, World! 
Поток 0: Hello, World! 
Поток 2: Hello, World! 
 
В программе поток №0 выполнился несколько раз из за того что количество секций больше числа потоков. 
 
 
Задать параллельный цикл for из 20 итераций. На каждой итерации пусть выводится её номер и номер потока, который эту итерацию выполняет. Объяснить результат. 
Текст программы: */

#include <iostream> 
#include <stdio.h> 
#include <omp.h> 
 
int main() 
{ 
setlocale(LC_ALL, "Russian"); 
#pragma omp parallel for 
for (int i = 1; i <= 20; i++) 
printf("Итерация %d поток %d.\n", i, omp_get_thread_num()); 
system("pause"); 
} 
 /*
Результат: 
Итерация 1 поток 0. 
Итерация 2 поток 0. 
Итерация 3 поток 0. 
Итерация 4 поток 0. 
Итерация 5 поток 0. 
Итерация 6 поток 1. 
Итерация 7 поток 1. 
Итерация 8 поток 1. 
Итерация 9 поток 1. 
Итерация 10 поток 1. 
Итерация 16 поток 3. 
Итерация 17 поток 3. 
Итерация 18 поток 3. 
Итерация 11 поток 2. 
Итерация 12 поток 2. 
Итерация 13 поток 2. 
Итерация 14 поток 2. 
Итерация 15 поток 2. 
Итерация 19 поток 3. 
Итерация 20 поток 3. 
 
Все итерации распределились между потоками. Работа между потоками распределяется поровну. 
 
В цикле из предыдущего задания изменить порядок распределения итераций цикла по потокам с помощью клауз schedule(static, m) и schedule(dynamic, m), где m=1,2,5,10. Объяснить полученные результаты. 
Текст программы: */

#include <iostream> 
#include <stdio.h> 
#include <omp.h> 
 
int main() 
{ 
setlocale(LC_ALL, "Russian"); 
int m[4] = { 1, 2, 5, 10 }; 
for (int k = 0; k < 4; k++) 
{ 
printf("static (m = %d)\n", m[k]); 
#pragma omp parallel for schedule (static, m[k]) 
for (int i = 1; i <= 20; i++) 
printf("Итерация %d поток %d.\n", i, omp_get_thread_num()); 
 
 
printf("\n\n\ndynamic(m = %d)\n", m[k]); 
#pragma omp parallel for schedule (dynamic, m[k]) 
for (int i = 1; i <= 20; i++) 
printf("Итерация %d поток %d.\n", i, omp_get_thread_num()); 
 
system("pause"); 
 
} 
} 
 /*
Результат: 
static (m = 1) 
Итерация 1 поток 0. 
Итерация 5 поток 0. 
Итерация 9 поток 0. 
Итерация 13 поток 0. 
Итерация 17 поток 0. 
Итерация 3 поток 2. 
Итерация 7 поток 2. 
Итерация 11 поток 2. 
Итерация 15 поток 2. 
Итерация 19 поток 2. 
Итерация 4 поток 3. 
Итерация 8 поток 3. 
Итерация 2 поток 1. 
Итерация 6 поток 1. 
Итерация 10 поток 1. 
Итерация 14 поток 1. 
Итерация 18 поток 1. 
Итерация 12 поток 3. 
Итерация 16 поток 3. 
Итерация 20 поток 3. 
 
 
 
dynamic(m = 1) 
Итерация 1 поток 0. 
Итерация 5 поток 0. 
Итерация 6 поток 0. 
Итерация 7 поток 0. 
Итерация 2 поток 3. 
Итерация 3 поток 1. 
Итерация 4 поток 2. 
Итерация 11 поток 2. 
Итерация 9 поток 3. 
Итерация 13 поток 3. 
Итерация 8 поток 0. 
Итерация 12 поток 2. 
Итерация 10 поток 1. 
Итерация 17 поток 1. 
Итерация 15 поток 0. 
Итерация 19 поток 0. 
Итерация 14 поток 3. 
Итерация 18 поток 1. 
Итерация 16 поток 2. 
Итерация 20 поток 0. 
 
 
 
static (m = 2) 
Итерация 7 поток 3. 
Итерация 8 поток 3. 
Итерация 15 поток 3. 
Итерация 16 поток 3. 
Итерация 5 поток 2. 
Итерация 3 поток 1. 
Итерация 1 поток 0. 
Итерация 6 поток 2. 
Итерация 4 поток 1. 
Итерация 2 поток 0. 
Итерация 13 поток 2. 
Итерация 11 поток 1. 
Итерация 9 поток 0. 
Итерация 14 поток 2. 
Итерация 12 поток 1. 
Итерация 19 поток 1. 
Итерация 20 поток 1. 
Итерация 10 поток 0. 
Итерация 17 поток 0. 
Итерация 18 поток 0. 
 
 
 
dynamic(m = 2) 
Итерация 1 поток 3. 
Итерация 3 поток 0. 
Итерация 4 поток 0. 
Итерация 7 поток 1. 
Итерация 8 поток 1. 
Итерация 5 поток 2. 
Итерация 6 поток 2. 
Итерация 2 поток 3. 
Итерация 15 поток 3. 
Итерация 16 поток 3. 
Итерация 13 поток 2. 
Итерация 14 поток 2. 
Итерация 9 поток 0. 
Итерация 10 поток 0. 
Итерация 11 поток 1. 
Итерация 19 поток 2. 
Итерация 20 поток 2. 
Итерация 12 поток 1. 
Итерация 17 поток 3. 
Итерация 18 поток 3. 
 
 
 
static (m = 5) 
Итерация 6 поток 1. 
Итерация 16 поток 3. 
Итерация 1 поток 0. 
Итерация 11 поток 2. 
Итерация 12 поток 2. 
Итерация 17 поток 3. 
Итерация 2 поток 0. 
Итерация 7 поток 1. 
Итерация 13 поток 2. 
Итерация 18 поток 3. 
Итерация 19 поток 3. 
Итерация 8 поток 1. 
Итерация 14 поток 2. 
Итерация 3 поток 0. 
Итерация 4 поток 0. 
Итерация 9 поток 1. 
Итерация 15 поток 2. 
Итерация 20 поток 3. 
Итерация 5 поток 0. 
Итерация 10 поток 1. 
 
 
 
dynamic(m = 5) 
Итерация 1 поток 0. 
Итерация 2 поток 0. 
Итерация 3 поток 0. 
Итерация 16 поток 2. 
Итерация 17 поток 2. 
Итерация 6 поток 1. 
Итерация 7 поток 1. 
Итерация 8 поток 1. 
Итерация 18 поток 2. 
Итерация 4 поток 0. 
Итерация 11 поток 3. 
Итерация 9 поток 1. 
Итерация 10 поток 1. 
Итерация 5 поток 0. 
Итерация 12 поток 3. 
Итерация 19 поток 2. 
Итерация 20 поток 2. 
Итерация 13 поток 3. 
Итерация 14 поток 3. 
Итерация 15 поток 3. 
 
 
 
static (m = 10) 
Итерация 11 поток 1. 
Итерация 1 поток 0. 
Итерация 2 поток 0. 
Итерация 3 поток 0. 
Итерация 4 поток 0. 
Итерация 12 поток 1. 
Итерация 5 поток 0. 
Итерация 13 поток 1. 
Итерация 6 поток 0. 
Итерация 14 поток 1. 
Итерация 7 поток 0. 
Итерация 8 поток 0. 
Итерация 15 поток 1. 
Итерация 16 поток 1. 
Итерация 9 поток 0. 
Итерация 10 поток 0. 
Итерация 17 поток 1. 
Итерация 18 поток 1. 
Итерация 19 поток 1. 
Итерация 20 поток 1. 
 
 
 
dynamic(m = 10) 
Итерация 1 поток 0. 
Итерация 2 поток 0. 
Итерация 3 поток 0. 
Итерация 4 поток 0. 
Итерация 5 поток 0. 
Итерация 11 поток 1. 
Итерация 6 поток 0. 
Итерация 7 поток 0. 
Итерация 12 поток 1. 
Итерация 13 поток 1. 
Итерация 8 поток 0. 
Итерация 9 поток 0. 
Итерация 14 поток 1. 
Итерация 10 поток 0. 
Итерация 15 поток 1. 
Итерация 16 поток 1. 
Итерация 17 поток 1. 
Итерация 18 поток 1. 
Итерация 19 поток 1. 
Итерация 20 поток 1. 
 
 
 
 
В заданиях №8-9 организовать параллельный вывод в такой массив, элемент которого с номером i будет хранить номер потока, который выполнил итерацию с номером i. Распечатать этот массив последовательно (и для static и для dynamic). 
 
1)schedule(static, m)  
Текст программы:  */

#include <omp.h> 
#include <iostream> 
 
using namespace std; 
void main() 
{ 
   int m = 0; 
   cin >> m; 
   int a[20]; 
#pragma omp parallel for schedule(static, m) 
   for (int i = 0; i < 20; i++) 
   { 
      a[i] = omp_get_thread_num(); 
   } 
   for (int i = 0; i < 20; i++) 
      cout << "a[" << i << "] = " << a[i] << '\n'; 
   system("pause"); 
} 
/*
M = 1  
a[0] = 0 
a[1] = 1 
a[2] = 2 
a[3] = 3 
a[4] = 0 
a[5] = 1 
a[6] = 2 
a[7] = 3 
a[8] = 0 
a[9] = 1 
a[10] = 2 
a[11] = 3 
a[12] = 0 
a[13] = 1 
a[14] = 2 
a[15] = 3 
a[16] = 0 
a[17] = 1 
a[18] = 2 
a[19] = 3 
M =2 
a[0] = 0 
a[1] = 0 
a[2] = 1 
a[3] = 1 
a[4] = 2 
a[5] = 2 
a[6] = 3 
a[7] = 3 
a[8] = 0 
a[9] = 0 
a[10] = 1 
a[11] = 1 
a[12] = 2 
a[13] = 2 
a[14] = 3 
a[15] = 3 
a[16] = 0 
a[17] = 0 
a[18] = 1 
a[19] = 1 
M = 5  
a[0] = 0  
a[1] = 0  
a[2] = 0  
a[3] = 0  
a[4] = 0  
a[5] = 1  
a[6] = 1  
a[7] = 1  
a[8] = 1  
a[9] = 1  
a[10] = 2  
a[11] = 2  
a[12] = 2  
a[13] = 2  
a[14] = 2  
a[15] = 3  
a[16] = 3  
a[17] = 3  
a[18] = 3  
a[19] = 3  
 
M = 10  
a[0] = 0  
a[1] = 0  
a[2] = 0  
a[3] = 0  
a[4] = 0  
a[5] = 0  
a[6] = 0  
a[7] = 0  
a[8] = 0  
a[9] = 0  
a[10] = 1  
a[11] = 1  
a[12] = 1  
a[13] = 1  
a[14] = 1  
a[15] = 1  
a[16] = 1  
a[17] = 1  
a[18] = 1  
a[19] = 1  
Комментарий  
Свободные потоки выполняют m итераций.  
 
2)schedule(dynamic, m)  
Текст программы:  */

#include <omp.h>  
#include <iostream>  
using namespace std; 
void main() 
{ 
   int m = 0; 
   cin >> m; 
   int a[20]; 
#pragma omp parallel for schedule(dynamic, m)  
   for (int i = 0; i < 20; i++) 
   { 
      a[i] = omp_get_thread_num(); 
   } 
   for (int i = 0; i < 20; i++) 
      cout << "a[" << i << "] = " << a[i] << '\n';; 
   system("pause"); 
}
/*
Результат работы программы:  
M = 1  
a[0] = 0  
a[1] = 0  
a[2] = 5  
a[3] = 1  
a[4] = 5  
a[5] = 1  
a[6] = 5  
a[7] = 1  
a[8] = 5  
a[9] = 1  
a[10] = 5  
a[11] = 1  
a[12] = 5  
a[13] = 1  
a[14] = 5  
a[15] = 1  
a[16] = 1  
a[17] = 1  
a[18] = 1  
a[19] = 1  
M = 2  
a[0] = 4  
a[1] = 4  
a[2] = 4  
a[3] = 4  
a[4] = 4  
a[5] = 4  
a[6] = 4  
a[7] = 4  
a[8] = 0  
a[9] = 0  
a[10] = 4  
a[11] = 4  
a[12] = 4  
a[13] = 4  
a[14] = 0  
a[15] = 0  
a[16] = 4  
a[17] = 4  
a[18] = 0  
a[19] = 0  
M = 5  
a[0] = 0  
a[1] = 0  
a[2] = 0  
a[3] = 0  
a[4] = 0  
a[5] = 6  
a[6] = 6  
a[7] = 6  
a[8] = 6  
a[9] = 6  
a[10] = 6  
a[11] = 6  
a[12] = 6  
a[13] = 6  
a[14] = 6  
a[15] = 6  
a[16] = 6  
a[17] = 6  
a[18] = 6  
a[19] = 6  
M = 10  
a[0] = 4  
a[1] = 4  
a[2] = 4  
a[3] = 4  
a[4] = 4  
a[5] = 4  
a[6] = 4  
a[7] = 4  
a[8] = 4  
a[9] = 4  
a[10] = 4  
a[11] = 4  
a[12] = 4  
a[13] = 4  
a[14] = 4  
a[15] = 4  
a[16] = 4  
a[17] = 4  
a[18] = 4  
a[19] = 4  
Комментарий  
Свободные потоки выполняют m итераций. 
 */
